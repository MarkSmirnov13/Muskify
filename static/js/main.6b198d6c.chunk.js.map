{"version":3,"sources":["masks/elon_musk.png","masks/blue_mask.png","utils/maskify.js","components/UploadButton/uploadButton.js","components/Spinner/Spinner.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","getOverlayValues","landmarks","jawline","getJawOutline","jawLeft","jawRight","splice","adjacent","x","opposite","y","width","Math","sqrt","pow","angle","atan2","PI","leftOffset","topOffset","length","masks","a","Promise","all","faceapi","tinyFaceDetector","loadFromUri","faceLandmark68TinyNet","catch","error","console","elonMuskImage","document","querySelector","spinner","imageUpload","item","handleImage","newImage","scale","style","withFaceLandmarks","detection","display","overlayValues","overlay","createElement","src","className","alt","cssText","appendChild","addEventListener","image","remove","files","naturalWidth","UploadButton","htmlFor","id","type","name","Spinner","App","useEffect","maskify","blueMask","elonMusk","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","message"],"mappings":"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","file":"static/js/main.6b198d6c.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/elon_musk.cff87dbe.png\";","module.exports = __webpack_public_path__ + \"static/media/blue_mask.ee96ab1b.png\";","import * as faceapi from 'face-api.js';\n\nconst getOverlayValues = landmarks => {\n    const jawline = landmarks.getJawOutline();\n    const jawLeft = jawline[0];\n    const jawRight = jawline.splice(-1)[0];\n    const adjacent = jawRight.x - jawLeft.x;\n    const opposite = jawRight.y - jawLeft.y;\n    const jawLength = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));\n    const angle = Math.atan2(opposite, adjacent) * (180 / Math.PI);\n    const width = jawLength * 1.8;\n\n    return {\n        width,\n        angle,\n        leftOffset: jawLeft.x - width * 0.21,\n        topOffset: jawline[jawline.length / 4].y - width * 0.53,\n    }\n};\n\nexport async function maskify(masks) {\n    await Promise.all([\n        faceapi.nets.tinyFaceDetector.loadFromUri('/static/models'),\n        faceapi.nets.faceLandmark68TinyNet.loadFromUri('/static/models'),\n    ]).catch(error => {\n        console.error('Error :(', error);\n    });\n\n    let image;\n    const elonMuskImage = document.querySelector('.elon-musk');\n    const spinner = document.querySelector('.spinner-box');\n    const imageUpload = document.querySelector('.file-upload__input');\n    const item = document.querySelector('.wrapper');\n    const handleImage = async (newImage, scale) => {\n        newImage.style.width = '400px';\n\n        const detection = await faceapi\n            .detectSingleFace(newImage, new faceapi.TinyFaceDetectorOptions())\n            .withFaceLandmarks(true);\n        spinner.style.display = 'none';\n\n        if (!detection) {\n            return;\n        }\n\n        const overlayValues = getOverlayValues(detection.landmarks);\n        const overlay = document.querySelector('.mask') || document.createElement('img');\n        overlay.src = masks[0];\n        overlay.className = 'mask';\n        overlay.alt = 'mask overlay';\n        overlay.style.cssText = `\n            position: absolute;\n            left: ${overlayValues.leftOffset * scale}px;\n            top: ${overlayValues.topOffset * scale}px;\n            width: ${overlayValues.width * scale}px;\n            transform: rotate(${overlayValues.angle}deg);\n        `;\n\n        item.appendChild(overlay);\n        item.appendChild(newImage);\n    };\n\n\n    imageUpload.addEventListener('change', async () => {\n        spinner.style.display = 'flex';\n        if (image) image.remove();\n        if (elonMuskImage) elonMuskImage.remove();\n\n        image = await faceapi.bufferToImage(imageUpload.files[0]);\n        image.className = 'image';\n        const scale = 400 / image.naturalWidth;\n        await handleImage(image, scale);\n    });\n}\n","import React from 'react';\n\nimport './uploadButton.css'\n\nconst UploadButton = () => {\n    return (\n        <div className='file-upload'>\n            <label htmlFor='upload' className='file-upload__label'>mask yourself</label>\n            <input id='upload' className='file-upload__input' type='file' name='file-upload' />\n        </div>\n    );\n};\n\nexport default UploadButton;\n","import React from 'react';\n\nimport './Spinner.css';\n\nconst Spinner = () => {\n    return (\n        <div className='spinner-box'>\n            <div className='circle-border'>\n                <div className='circle-core' />\n            </div>\n        </div>\n    );\n};\n\nexport default Spinner;\n","import React, { useEffect } from 'react';\n\nimport { maskify } from './utils/maskify';\nimport elonMusk from './masks/elon_musk.png';\nimport blueMask from './masks/blue_mask.png';\nimport UploadButton from './components/UploadButton/uploadButton'\nimport './App.css';\nimport Spinner from \"./components/Spinner\";\n\nfunction App() {\n\n    useEffect(() => {\n        maskify([\n            blueMask,\n        ]).catch(error => {\n            console.error('Error', error);\n        });\n    }, []);\n\n    return (\n        <div className='App'>\n            <div className='title'>MUSKIFY</div>\n            <Spinner />\n            <div className='wrapper'>\n                <img src={elonMusk} alt='elon musk' className='elon-musk' />\n            </div>\n            <UploadButton />\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}